<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Searching &mdash; ME 400 Course Notes Fall 2018 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'Fall 2018',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ME 400 Course Notes Fall 2018 documentation" href="../index.html" />
    <link rel="next" title="Lecture 15 - Sorting" href="Sorting.html" />
    <link rel="prev" title="Lecture 13 - More on Functions" href="More_on_Functions.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput div.prompt,
div.nbinput div.input_area,
div.nbinput div[class*=highlight],
div.nbinput div[class*=highlight] pre,
div.nboutput,
div.nbinput div.prompt,
div.nbinput div.output_area,
div.nboutput div[class*=highlight],
div.nboutput div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput,
    div.nboutput {
        flex-direction: column;
    }
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput div.prompt pre {
    color: #303F9F;
}

/* output prompt */
div.nboutput div.prompt pre {
    color: #D84315;
}

/* all prompts */
div.nbinput div.prompt,
div.nboutput div.prompt {
    min-width: 8ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput div.prompt,
    div.nboutput div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput div.prompt pre,
div.nboutput div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput div.input_area,
div.nboutput div.output_area {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput div.input_area,
    div.nboutput div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }
</style>
<div class="section" id="Searching">
<h1>Searching<a class="headerlink" href="#Searching" title="Permalink to this headline">¶</a></h1>
<div class="section" id="Overview,-Objectives,-and-Key-Terms">
<h2>Overview, Objectives, and Key Terms<a class="headerlink" href="#Overview,-Objectives,-and-Key-Terms" title="Permalink to this headline">¶</a></h2>
<p>In this lecture and <a class="reference external" href="ME400_Lecture_15.ipynb">Lecture 15</a>, we tackle
two of the most important practical problems in computing: <em>searching</em>
and <em>sorting</em>. We&#8217;ll start with <em>searching</em> in this lecture because it
is the simpler problem, but efficient searching depends on sorted
values. Along the way, algorithms will be classified by their <em>order</em>, a
way to describe how good (or bad) an algorithm is for problems of
different sizes.</p>
<div class="section" id="Objectives">
<h3>Objectives<a class="headerlink" href="#Objectives" title="Permalink to this headline">¶</a></h3>
<p>By the end of this lesson, you should be able to</p>
<ul class="simple">
<li>Search an array of numbers using a linear search.</li>
<li>Search an array of numbers using a binary search.</li>
<li>Describe what is meant by order and use it to compare algorithms</li>
<li>Perform simple, numerical experiments to confirm the order of an
algorithm</li>
</ul>
</div>
<div class="section" id="Key-Terms">
<h3>Key Terms<a class="headerlink" href="#Key-Terms" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>linear search</li>
<li>binary search</li>
<li><code class="docutils literal"><span class="pre">time.time()</span></code></li>
<li>numerical experiment</li>
<li>order</li>
<li><span class="math">\(\mathcal{O}\)</span> (big-O) notation</li>
</ul>
</div>
</div>
<div class="section" id="The-Basic,-Linear-Search">
<h2>The Basic, Linear Search<a class="headerlink" href="#The-Basic,-Linear-Search" title="Permalink to this headline">¶</a></h2>
<p>A search algorithm solves the following problem: given a sequence of
values, find the location of the element in the sequence equal to some
value of interest. If all we want is equality, then the order of the
elements does not matter, and a simple solution is a <strong>linear search</strong>
of the unsorted sequence. Linear search algorithms represent the
brute-force approach: search every element in the sequence, from one end
to the other, until the match is found. The algorithm can be summarized
in pseudocode as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Algorithm for linear search of an unsorted sequence&quot;&quot;&quot;</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="c1"># sequence, number elements, value of interest</span>
<span class="n">Set</span> <span class="n">location</span> <span class="o">=</span> <span class="n">Not</span> <span class="n">found</span>
<span class="n">Set</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">While</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
    <span class="n">If</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span> <span class="n">then</span>
        <span class="n">Set</span> <span class="n">location</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">Break</span>  <span class="c1"># stealing an idea from the Python we&#39;ve learned</span>
    <span class="n">Set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">location</span>
</pre></div>
</div>
<p>Searching requires that an expression line <code class="docutils literal"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">v</span></code> has meaning.
For <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, and <code class="docutils literal"><span class="pre">str</span></code> values, it does. For more
complicated types, it might not be so obvious. Are the lists
<code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> and <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">2]</span></code> equal? In total, no, but some elements
are, and maybe that&#8217;s what matters.</p>
<blockquote>
<div><strong>Exercise</strong>: Implement this algorithm in Python and test with
sequence <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">6,</span> <span class="pre">1,</span> <span class="pre">7,</span> <span class="pre">3]</span></code> and value <code class="docutils literal"><span class="pre">7</span></code>.</div></blockquote>
<p>One does not need to sort values before searching them with a linear
search if <em>equality</em> is to be checked. However, what if one wants to
find (1) the location of an element in a sequence equal to some value
or, if not found, (2) the location of the value that is closest to but
less than the value of interest. For this latter case, values need to be
sorted. Those algorithms will be studied next time, but an easy way to
sort a sequence is with the <code class="docutils literal"><span class="pre">sorted()</span></code> function:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[1]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>[1, 2, 3, 6, 7]
</pre></div>
</div>
</div>
<p>Hence, we can modify somewhat the pseudocode to search sorted values and
to find the first element equal to (or the first element greater than) a
value of interest.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Algorithm for linear search of a sorted sequence&quot;&quot;&quot;</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="c1"># sorted sequence, number elements, value of interest</span>
<span class="n">Set</span> <span class="n">location</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">Set</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">While</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
    <span class="n">If</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span> <span class="n">then</span>
        <span class="n">Set</span> <span class="n">location</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">Break</span>
    <span class="n">Set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">location</span>
</pre></div>
</div>
<p>Lets implement this algorithm as a function:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search a sorted sequence for value v. Return nearest</span>
<span class="sd">       index to right (or last position) if not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">location</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">location</span>
</pre></div>
</div>
</div>
<p>Now, let&#8217;s test it on a sorted array and search for a few values:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>
<span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># expect 2</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[3]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>2
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># expect 0</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[4]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>0
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span> <span class="c1"># expect 4</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[5]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>4
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span> <span class="c1"># expect 4 again</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[6]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>4
</pre></div>
</div>
</div>
<p>So far, so good. Does it work for all values of <code class="docutils literal"><span class="pre">v</span></code>?</p>
<blockquote>
<div><p><strong>Exercise</strong>: Produce a flow chart for the linear search algorithm
(for sorted sequences).</p>
<p><strong>Exercise</strong>: Modify the <code class="docutils literal"><span class="pre">linear_search</span></code> algorithm to accept a
third argument <code class="docutils literal"><span class="pre">compare</span></code>, which should be a function that accepts
two arguments. For a sequence <code class="docutils literal"><span class="pre">a</span></code> and value <code class="docutils literal"><span class="pre">v</span></code>,
<code class="docutils literal"><span class="pre">compare(a[i],</span> <span class="pre">v)</span></code> should return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">a[i]</span></code> is greater
than or equal to <code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">False</span></code> otherwise. Test your modified
search function with <code class="docutils literal"><span class="pre">compare</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x[1]</span> <span class="pre">&gt;</span> <span class="pre">y[1]</span></code>,
<code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[(1,</span> <span class="pre">2),</span> <span class="pre">(4,</span> <span class="pre">3),</span> <span class="pre">(1,</span> <span class="pre">9),</span> <span class="pre">(4,</span> <span class="pre">11)]</span></code> and <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">9)</span></code>.</p>
<blockquote>
<div><em>Solution</em>:</div></blockquote>
</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search a sorted sequence for value v. Return nearest</span>
<span class="sd">       index to left if not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">location</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">location</span>
<span class="c1"># Now test it</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="A-Bit-About-Order">
<h2>A Bit About Order<a class="headerlink" href="#A-Bit-About-Order" title="Permalink to this headline">¶</a></h2>
<p>Why call linear search <em>linear</em>? One reason might be that the process is
pretty linear in that each element is checked one after another (i.e.,
no skipping around the elements to find the proverbial needle). Another
reason is that the number of times elements have to be compared (i.e.,
the number of times <code class="docutils literal"><span class="pre">a[i]</span> <span class="pre">&gt;</span> <span class="pre">v</span></code> is evaluated) is proportional (and, in
the worst, case <em>equal</em>) to the number of elements. Any time we have a
proportional relationship, that relationship is <em>linear</em>. The familiar
<span class="math">\(y = ax + b\)</span> is linear, because <span class="math">\(y\)</span> varies linearly with
<span class="math">\(x\)</span>. For an array of <span class="math">\(n\)</span> elements, the number of comparisons
is linear with <span class="math">\(n\)</span>. The exact number of comparisons depends on the
value for which one is searching and the sequence of values.</p>
<p>Generically, this linear relationship is given the fancy name <em>order
:math:`n`</em>, written compactly in the <a class="reference external" href="https://en.wikipedia.org/wiki/Big_O_notation">big
O</a> notation
<span class="math">\(\mathcal{O}(n)\)</span>. Quite frequently, the computational cost of an
algorithm (i.e., how long it takes to run) is directly proportional to
its order. Hence, the time it takes for linear search to find its match
should grow, roughly linearly, with the number of elements being
searched.</p>
<p>This fact may be intuitive, but it&#8217;s always nice to see things
demonstrated. Here&#8217;s what we&#8217;ll do. We&#8217;ll write a little loop that goes
from <span class="math">\(n = 10\)</span> to <span class="math">\(n = 10^6\)</span>. At each size of <span class="math">\(n\)</span>,
we&#8217;ll draw a random number from 1 to <span class="math">\(10^6\)</span> and search for it in
the <code class="docutils literal"><span class="pre">np.arange(1,</span> <span class="pre">n+1)</span></code>, a sorted sequence for sure. For each step,
we&#8217;ll time things. All together, these steps form the basis for a
<strong>numerical experiment</strong>. Here it all is:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Program to show time as a function of size for linear search.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c1"># Set the seed to keep the output fixed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>

<span class="c1"># Set the n values and initialize a list for times</span>
<span class="n">n_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">t_values</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_values</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># Generate the array 1, 2, ..., n</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Get a random int from [1, n]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Start the timer</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="c1"># Do the search</span>
    <span class="n">location</span> <span class="o">=</span> <span class="n">linear_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># Determine the elapsed time (in seconds) and save it</span>
    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_start</span>
    <span class="n">t_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_elapsed</span><span class="p">)</span>

<span class="c1"># Plot the times vs values on a log log plot.</span>
<span class="c1"># Also, an expected &quot;trend&quot; line is included.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">n_values</span><span class="p">,</span> <span class="n">t_values</span><span class="p">,</span> <span class="s1">&#39;k-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;times&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">n_values</span><span class="p">,</span> <span class="mf">1e-7</span><span class="o">*</span><span class="n">n_values</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\mathcal{O}(n)$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/lectures_Searching_13_0.png" src="../_images/lectures_Searching_13_0.png" />
</div>
</div>
<p>Based on the figure, the times are not perfectly linear with <span class="math">\(n\)</span>,
but then again, the experiment is based on searching for a random value
(which could be at the very beginning or the very end of the sorted
array). A more complete approach would be to do the search <em>at each
:math:`n` several times</em> and average the resulting elapsed times.</p>
<blockquote>
<div><strong>Exercise</strong>: Modify the program above so that five different values
of <code class="docutils literal"><span class="pre">v</span></code> are selected for each value of <code class="docutils literal"><span class="pre">n</span></code>. Then, average the
times and plot the results.</div></blockquote>
<p>Such <strong>numerical experiments</strong> based on randome numbers are great ways
to explore the behavior of algorithms for a variety of inputs.</p>
</div>
<div class="section" id="Binary-Search">
<h2>Binary Search<a class="headerlink" href="#Binary-Search" title="Permalink to this headline">¶</a></h2>
<p><strong>Linear search</strong> is easy to understand and easy to implement, but it is
not the fastest way to search, and it&#8217;s probably not what you use when
searching ordered data.</p>
<p>Think about real-life scenarios in which ordered data is searched by
hand. One such scenario is when looking up a word in a dictionary (an
actual, dead-tree book, not the website with the search tool). Surely,
you don&#8217;t flip through, page by page, from &#8220;a&#8221; to &#8220;z,&#8221; until the item is
found. Rather, you likely take a large jump to the letter of interest (a
bonafide search algorithm for things organized into smaller collections
like alphabetized words). If you&#8217;re like me, you then quickly identify a
page near to but <em>before</em> the one of interest and a page near to but
<em>after</em> the one of interest. Next, you check some page between those. If
it contains the word of interest, great, your job is done. If it is
before (or after) the word of interest, you have just reduced the number
of pages to search by about two.</p>
<p>The process just described is the basic idea of <strong>binary search</strong>:
always divide the search domain in half. One can consider binary search
to be the simplest of <strong>divide and conquer</strong> techniques. <a class="reference external" href="ME400_Lecture_15.ipynb">Lecture
15</a> will show how divide and conquer applies
to the problem of sorting.</p>
<div class="section" id="The-basic-algorithm">
<h3>The basic algorithm<a class="headerlink" href="#The-basic-algorithm" title="Permalink to this headline">¶</a></h3>
<p>For a sorted sequence <code class="docutils literal"><span class="pre">a</span></code> of <code class="docutils literal"><span class="pre">n</span></code> values, a simple, binary search
algorithm is defined by the following pseudocode:</p>
<div class="highlight-octave"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;&quot;Algorithm for binary search of a sorted sequence&quot;&quot;&quot;</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="c"># Sorted sequence, number elements, value of interest</span>

<span class="c"># Initialize the location</span>
<span class="n">Set</span> <span class="n">location</span> <span class="p">=</span> <span class="n">Not</span> <span class="n">Found</span>
<span class="c"># Set the left and right search bounds</span>
<span class="n">Set</span> <span class="n">L</span> <span class="p">=</span> <span class="mi">0</span>
<span class="n">Set</span> <span class="n">R</span> <span class="p">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">While</span> <span class="n">L</span> <span class="o">&lt;</span><span class="p">=</span> <span class="n">R</span>
    <span class="c"># Set the central point (use integer division!)</span>
    <span class="n">Set</span> <span class="n">C</span> <span class="p">=</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">R</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">If</span> <span class="n">v</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">C</span><span class="p">]</span> <span class="n">then</span>
        <span class="c"># Our search is successful, so we set</span>
        <span class="c"># the location and call it quits early.</span>
        <span class="n">Set</span> <span class="n">location</span> <span class="p">=</span> <span class="n">C</span>
        <span class="n">Break</span>
    <span class="n">If</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">C</span><span class="p">]</span> <span class="n">then</span>
        <span class="c"># V is in the first half of a[L:R],</span>
        <span class="c"># so modify the right bound</span>
        <span class="n">Set</span> <span class="n">R</span> <span class="p">=</span> <span class="n">C</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">If</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">C</span><span class="p">]</span> <span class="n">then</span>
        <span class="c"># V is in the second half of a[L:R]</span>
        <span class="c"># so modify the left bound</span>
        <span class="n">Set</span> <span class="n">L</span> <span class="p">=</span> <span class="n">C</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This algorithm is substantially more complex than linear search. Notice
what happens at each step: either (1) the value <code class="docutils literal"><span class="pre">v</span></code> is found or (2)
one of the bounds (<code class="docutils literal"><span class="pre">L</span></code> or <code class="docutils literal"><span class="pre">R</span></code>) are changed, reducing the range to be
searched by half.</p>
<blockquote>
<div><p><strong>Exercise</strong>: Step through this algorithm for
<code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code> and <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">3</span></code>. We know that <code class="docutils literal"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">0</span></code> and
<code class="docutils literal"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">4</span></code> before the loop begins. What are <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">R</span></code> after one
time through the loop? Twice? Three times? If it helps, you can add
<code class="docutils literal"><span class="pre">Set</span> <span class="pre">counter</span> <span class="pre">=</span> <span class="pre">0</span></code> before the <code class="docutils literal"><span class="pre">While</span></code> and increment it. Then,
trace the values of <code class="docutils literal"><span class="pre">counter</span></code>, <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, and <code class="docutils literal"><span class="pre">C</span></code> at each
iteration.</p>
<p><strong>Exercise</strong>: Do the same for <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">2</span></code> (which is not in <code class="docutils literal"><span class="pre">a</span></code>).</p>
<p><strong>Exercise</strong>: Develop a flowchart for the binary search algorithm
shown above in pseudocode.</p>
</div></blockquote>
</div>
<div class="section" id="Back-to-Order">
<h3>Back to Order<a class="headerlink" href="#Back-to-Order" title="Permalink to this headline">¶</a></h3>
<p>Linear search is <span class="math">\(\mathcal{O}(n)\)</span>, i.e., order <span class="math">\(n\)</span>. Binary
search is faster. It requires fewer comparisons. Think about it this
way: apply both search algorithms to find <code class="docutils literal"><span class="pre">9</span></code> in <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code>.
At each step, the elements left to search are as follows (where the
bolded entry indicates the element is found at that step):</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="43%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Step</th>
<th class="head">Linear</th>
<th class="head">Binary</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td><code class="docutils literal"><span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code></td>
<td><code class="docutils literal"><span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code></td>
</tr>
<tr class="row-odd"><td>1</td>
<td><code class="docutils literal"><span class="pre">[3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code></td>
<td><strong>[9, 11]</strong></td>
</tr>
<tr class="row-even"><td>2</td>
<td><code class="docutils literal"><span class="pre">[7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td><strong>[9, 11]</strong></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Here, it appears binary search outperforms linear search by about a
factor of two, but in general it is <em>much better</em>. In fact, binary
search is <span class="math">\(\mathcal{O}(\log n)\)</span>. More specifically, the number of
comparisons required is proportional to <span class="math">\(\log_2 n\)</span>, but remember
that <span class="math">\(\log_x n = \alpha \log_y n\)</span> for <span class="math">\(\alpha = \log_x(y)\)</span>.
How <em>much</em> better is <span class="math">\(\mathcal{O}(\log n)\)</span> than
<span class="math">\(\mathcal{O}(n)\)</span>?</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;For n = {:7.0f}, binary is better by about a factor of {:.1e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
For n =      10, binary is better by about a factor of 4.3e+00
For n =     100, binary is better by about a factor of 2.2e+01
For n =    1000, binary is better by about a factor of 1.4e+02
For n =   10000, binary is better by about a factor of 1.1e+03
For n =  100000, binary is better by about a factor of 8.7e+03
For n = 1000000, binary is better by about a factor of 7.2e+04
</pre></div></div>
</div>
<p>That&#8217;s a huge savings when <span class="math">\(n\)</span> is greater than about 10! The
savings just get better with larger <span class="math">\(n\)</span>.</p>
<blockquote>
<div><p><strong>Exercise</strong>: Implement the binary search algorithm above as a
Python function <code class="docutils literal"><span class="pre">binary_search_basic</span></code>.</p>
<p><strong>Exercise</strong>: Implement a <em>modified</em> binary search algorithm in
Python as a function <code class="docutils literal"><span class="pre">binary_search</span></code> that returns the location of
the element nearest to but less than <code class="docutils literal"><span class="pre">v</span></code> when <code class="docutils literal"><span class="pre">v</span></code> is not found.</p>
<p><strong>Exercise</strong>: Repeat the numerical experiment performed above using
<code class="docutils literal"><span class="pre">binary_search</span></code> in place of <code class="docutils literal"><span class="pre">linear_search</span></code>. Make sure to
replace the trend line with what you expect.</p>
<p><strong>Exercise</strong>: Implement the binary search function using recursion.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="A-Comment-on-Built-In-Functions">
<h2>A Comment on Built-In Functions<a class="headerlink" href="#A-Comment-on-Built-In-Functions" title="Permalink to this headline">¶</a></h2>
<p>Given <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">9,</span> <span class="pre">11]</span></code>, Python already has a way to find the
location of <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">9</span></code>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[9]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>3
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">help</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on built-in function index:

index(...) method of builtins.list instance
    L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.
    Raises ValueError if the value is not present.

</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">ValueError</span>                                Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-11-8e455ff4af22&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-fg">----&gt; 1</span><span class="ansi-red-fg"> </span>a<span class="ansi-blue-fg">.</span>index<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">2</span><span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">ValueError</span>: 2 is not in list
</pre></div></div>
</div>
<p>The <code class="docutils literal"><span class="pre">index</span></code> function does not require that the elements of <code class="docutils literal"><span class="pre">a</span></code> be
sorted:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[12]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>3
</pre></div>
</div>
</div>
<p>Based on the documentation, it&#8217;s not clear what sort of search is
powering the <code class="docutils literal"><span class="pre">index</span></code> function. You could dig in to the underlying
code, or you could try a numerical experiment!</p>
<blockquote>
<div><strong>Exercise</strong>: Adapt the numerical experiment above to determine
whether the <code class="docutils literal"><span class="pre">index</span></code> function is linear or binary. Does its
behavior change if <code class="docutils literal"><span class="pre">a</span></code> is unsorted?</div></blockquote>
</div>
<div class="section" id="Further-Reading">
<h2>Further Reading<a class="headerlink" href="#Further-Reading" title="Permalink to this headline">¶</a></h2>
<p>None at this time.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Searching</a><ul>
<li><a class="reference internal" href="#Overview,-Objectives,-and-Key-Terms">Overview, Objectives, and Key Terms</a><ul>
<li><a class="reference internal" href="#Objectives">Objectives</a></li>
<li><a class="reference internal" href="#Key-Terms">Key Terms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#The-Basic,-Linear-Search">The Basic, Linear Search</a></li>
<li><a class="reference internal" href="#A-Bit-About-Order">A Bit About Order</a></li>
<li><a class="reference internal" href="#Binary-Search">Binary Search</a><ul>
<li><a class="reference internal" href="#The-basic-algorithm">The basic algorithm</a></li>
<li><a class="reference internal" href="#Back-to-Order">Back to Order</a></li>
</ul>
</li>
<li><a class="reference internal" href="#A-Comment-on-Built-In-Functions">A Comment on Built-In Functions</a></li>
<li><a class="reference internal" href="#Further-Reading">Further Reading</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="More_on_Functions.html" title="previous chapter">Lecture 13 - More on Functions</a></li>
      <li>Next: <a href="Sorting.html" title="next chapter">Lecture 15 - Sorting</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/lectures/Searching.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jeremy Roberts.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/lectures/Searching.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>